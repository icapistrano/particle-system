import{r as i,j as s}from"./index-D2MUXnTG.js";import{V as l,C as w,P as z,M as S,u as A}from"./MouseHandler-BtVpYj15.js";const V="attribute float scale;attribute vec3 color;varying vec3 vColor;void main(){vec4 mvPosition=modelViewMatrix*vec4(position,1.0);gl_Position=projectionMatrix*mvPosition;float scaleT=scale/-mvPosition.z;gl_PointSize=scaleT;vColor=mix(vec3(1.0),color,scaleT);}",_="varying vec3 vColor;void main(){float distance=length(gl_PointCoord-vec2(0.5));float alpha=1.0-smoothstep(0.49,0.5,distance);if(alpha<0.5){discard;}gl_FragColor=vec4(vColor,alpha);}",M=[[1,0,0],[0,1,0],[0,0,1]],F=()=>M[Math.floor(Math.random()*M.length)],E=()=>{const a=i.useRef(new l);return s.jsxs(w,{className:"cursor-crosshair bg-dark",children:[s.jsx(z,{makeDefault:!0,position:[0,0,10]}),s.jsx(S,{mousePositionRef:a}),s.jsx(T,{mousePos:a.current})]})},T=({mousePos:a,distanceThreshold:b=2.5,sphereRad:h=2,particleCount:r=3e3})=>{const u=i.useRef(new l),v=i.useRef(null),j=i.useRef(null),d=i.useRef(new Float32Array(r*3)),m=i.useRef(new Float32Array(r*3)),x=i.useRef(new Float32Array(r)),R=i.useMemo(()=>{const t=Math.PI*(3-Math.sqrt(5));return Array.from({length:r},(f,o)=>{const e=t*o,c=Math.acos(1-2*(o+.5)/r),n=h*Math.sin(c)*Math.cos(e),y=h*Math.sin(c)*Math.sin(e),g=h*Math.cos(c);return{originalPosition:new l(n,y,g),position:new l(n,y,g),velocity:new l,scale:1,color:new l().fromArray(F())}})},[r,h]),P=(t,f)=>{const o=t.position.distanceTo(a),e=a.x+a.y+a.z!==0&&o<=b;if(u.current.set(0,0,0),e){u.current.subVectors(a,t.position),u.current.normalize();const c=Math.max(.2,1-o/3);t.velocity.addScaledVector(u.current,c*f),t.scale=Math.min(200,t.scale+Math.log(o*1.5))}else u.current.subVectors(t.originalPosition,t.position),t.velocity.addScaledVector(u.current,f),t.velocity.multiplyScalar(.95),t.scale=Math.max(1,t.scale-Math.log(t.scale));t.position.add(t.velocity)};return A((t,f)=>{if(!v.current)return;R.forEach((e,c)=>{P(e,f);const n=c*3;d.current[n]=e.position.x,d.current[n+1]=e.position.y,d.current[n+2]=e.position.z,m.current[n]=e.color.x,m.current[n+1]=e.color.y,m.current[n+2]=e.color.z,x.current[c]=e.scale});const o=v.current.geometry;o.attributes.position.needsUpdate=!0,o.attributes.color.needsUpdate=!0,o.attributes.scale.needsUpdate=!0}),s.jsxs("points",{ref:v,children:[s.jsxs("bufferGeometry",{children:[s.jsx("bufferAttribute",{attach:"attributes-position",array:d.current,itemSize:3,count:r}),s.jsx("bufferAttribute",{attach:"attributes-color",array:m.current,itemSize:3,count:r}),s.jsx("bufferAttribute",{attach:"attributes-scale",array:x.current,itemSize:1,count:r})]}),s.jsx("shaderMaterial",{ref:j,fragmentShader:_,vertexShader:V})]})};export{E as BlobNoiseScene,E as default};
